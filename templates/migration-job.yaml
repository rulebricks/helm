{{/*
Migration Job for Self-Hosted Supabase
Uses psql to apply migrations directly to the self-hosted Postgres database
*/}}
{{- if .Values.supabase.enabled -}}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-db-migrate-{{ .Release.Revision }}
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: {{ .Chart.Name }}-migrations
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/component: migrations
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ .Chart.Name }}-migrations
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      restartPolicy: OnFailure
      imagePullSecrets:
        - name: {{ .Release.Name }}-regcred
      initContainers:
        - name: extract-assets
          # Use the configured migration image or fallback to app image
          image: "{{ .Values.rulebricks.app.image.repository }}:{{ .Values.rulebricks.app.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: IfNotPresent
          command: ["/bin/sh", "-c"]
          args:
            - |
              echo "Extracting Supabase assets..."
              # Copy the assets from the image to the shared volume
              # Path based on CLI logic: /opt/rulebricks/assets/supabase
              if [ -d "/opt/rulebricks/assets/supabase" ]; then
                cp -r /opt/rulebricks/assets/supabase/* /assets/
                echo "Assets extracted successfully."
              else
                echo "Warning: /opt/rulebricks/assets/supabase not found in image."
              fi
          volumeMounts:
            - name: assets
              mountPath: /assets
      containers:
        - name: migrate
          # Use a postgres client image to run the migrations
          image: postgres:15-alpine
          imagePullPolicy: IfNotPresent
          command: ["/bin/sh", "-c"]
          args:
            - |
              echo "Waiting for database to be ready..."
              until pg_isready -h $DB_HOST -p $DB_PORT -U $DB_USER; do
                echo "Waiting for postgres..."
                sleep 2
              done

              echo "Running database migrations..."
              
              # Export PGPASSWORD for psql
              export PGPASSWORD=$DB_PASSWORD

              # Create schema_migrations table if not exists
              psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -c "
                CREATE TABLE IF NOT EXISTS schema_migrations (
                  version VARCHAR(255) PRIMARY KEY,
                  applied_at TIMESTAMP DEFAULT NOW()
                );"

              # Function to check if migration is applied
              is_applied() {
                psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -t -c "SELECT 1 FROM schema_migrations WHERE version = '$1';" | grep -q 1
              }

              # Iterate over migration files
              if [ -d "/assets/migrations" ]; then
                for f in /assets/migrations/*.sql; do
                  [ -e "$f" ] || continue
                  
                  # Extract version (filename)
                  version=$(basename "$f")
                  
                  if is_applied "$version"; then
                    echo "Skipping $version (already applied)"
                  else
                    echo "Applying $version..."
                    if psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f "$f"; then
                      psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -c "INSERT INTO schema_migrations (version) VALUES ('$version');"
                      echo "Successfully applied $version"
                    else
                      echo "Failed to apply $version"
                      exit 1
                    fi
                  fi
                done
              else
                echo "No migrations found in /assets/migrations"
              fi
              
              echo "Migrations completed."
          env:
            - name: DB_HOST
              # Templated Supabase DB service name: <release>-supabase-db
              value: "{{ .Release.Name }}-supabase-db"
            - name: DB_PORT
              value: "5432"
            - name: DB_USER
              value: {{ .Values.supabase.secret.db.username | default "postgres" | quote }}
            - name: DB_NAME
              value: {{ .Values.supabase.secret.db.database | default "postgres" | quote }}
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  # Supabase chart creates secret named: <release>-supabase-db
                  name: {{ .Release.Name }}-supabase-db
                  key: password
          volumeMounts:
            - name: assets
              mountPath: /assets
      volumes:
        - name: assets
          emptyDir: {}
{{- end }}
---
{{/*
Migration Job for Managed (External) Supabase
Uses Supabase CLI to push schema and configuration to a managed Supabase project
Requires either:
  - global.supabase.accessToken to be set directly, OR
  - global.secrets.secretRef pointing to a secret containing SUPABASE_ACCESS_TOKEN
*/}}
{{- $hasAccessToken := false }}
{{- $useSecretRef := false }}
{{- if and .Values.global .Values.global.secrets .Values.global.secrets.secretRef }}
  {{- $useSecretRef = true }}
  {{- $hasAccessToken = true }}
{{- else if and .Values.global .Values.global.supabase .Values.global.supabase.accessToken }}
  {{- $hasAccessToken = true }}
{{- end }}
{{- if and (not .Values.supabase.enabled) $hasAccessToken -}}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-managed-supabase-setup-{{ .Release.Revision }}
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: {{ .Chart.Name }}-managed-supabase-setup
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/component: managed-supabase-setup
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ .Chart.Name }}-managed-supabase-setup
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      restartPolicy: OnFailure
      imagePullSecrets:
        - name: {{ .Release.Name }}-regcred
      initContainers:
        - name: extract-assets
          # Use the configured migration image or fallback to app image
          image: "{{ .Values.rulebricks.app.image.repository }}:{{ .Values.rulebricks.app.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: IfNotPresent
          command: ["/bin/sh", "-c"]
          args:
            - |
              echo "Extracting Supabase assets..."
              # Copy the assets from the image to the shared volume
              # Path based on CLI logic: /opt/rulebricks/assets/supabase
              if [ -d "/opt/rulebricks/assets/supabase" ]; then
                cp -r /opt/rulebricks/assets/supabase /assets/
                echo "Assets extracted successfully."
              else
                echo "Error: /opt/rulebricks/assets/supabase not found in image."
                exit 1
              fi
          volumeMounts:
            - name: assets
              mountPath: /assets
      containers:
        - name: supabase-setup
          # Use Node.js Alpine and install Supabase CLI at runtime
          image: node:20-alpine
          imagePullPolicy: IfNotPresent
          workingDir: /assets
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -e
              
              echo "=== Managed Supabase Setup ==="
              
              # Install CA certificates for SSL connections and curl for downloading templates
              echo "Installing CA certificates and curl..."
              apk add --no-cache ca-certificates curl
              
              echo "Installing Supabase CLI locally..."
              npm init -y
              npm install supabase --save-dev
              
              # Create templates directory
              mkdir -p supabase/templates
              
              # Derive PROJECT_REF from URL if not explicitly provided
              PROJECT_REF="${SUPABASE_PROJECT_REF}"
              if [ -z "$PROJECT_REF" ] && [ -n "$SUPABASE_URL" ]; then
                PROJECT_REF=$(echo "$SUPABASE_URL" | sed -n 's|https://\([^.]*\)\.supabase\.co.*|\1|p')
                echo "Derived project ref from URL: $PROJECT_REF"
              fi
              
              if [ -z "$PROJECT_REF" ]; then
                echo "Error: Could not determine project reference."
                echo "Please set global.supabase.projectRef or provide a valid global.supabase.url"
                exit 1
              fi
              
              # Authenticate with Supabase CLI
              echo "Authenticating with Supabase..."
              npx supabase login --token "$SUPABASE_ACCESS_TOKEN"
              
              # Create config.toml from template with variable replacements
              TEMPLATE_FILE="supabase/config.example.toml"
              if [ -n "$TEMPLATE_FILE" ]; then
                echo "Creating config.toml from template..."
                cp "$TEMPLATE_FILE" supabase/config.toml
                
                # Replace URL placeholder
                sed -i "s|env(FULL_URL)|https://${SITE_DOMAIN}|g" supabase/config.toml
                
                # Replace email subject placeholders
                sed -i "s|env(EMAIL_SUBJECTS_INVITE)|${EMAIL_SUBJECTS_INVITE}|g" supabase/config.toml
                sed -i "s|env(EMAIL_SUBJECTS_CONFIRMATION)|${EMAIL_SUBJECTS_CONFIRMATION}|g" supabase/config.toml
                sed -i "s|env(EMAIL_SUBJECTS_RECOVERY)|${EMAIL_SUBJECTS_RECOVERY}|g" supabase/config.toml
                sed -i "s|env(EMAIL_SUBJECTS_EMAIL_CHANGE)|${EMAIL_SUBJECTS_EMAIL_CHANGE}|g" supabase/config.toml
                
                # Download email templates and replace URLs with local paths
                mkdir -p ./templates
                echo "Downloading email templates..."
                curl -sSL "$EMAIL_TEMPLATES_INVITE" -o ./templates/invite.html && \
                  sed -i "s|$EMAIL_TEMPLATES_INVITE|./templates/invite.html|g" supabase/config.toml
                curl -sSL "$EMAIL_TEMPLATES_CONFIRMATION" -o ./templates/verify.html && \
                  sed -i "s|$EMAIL_TEMPLATES_CONFIRMATION|./templates/verify.html|g" supabase/config.toml
                curl -sSL "$EMAIL_TEMPLATES_RECOVERY" -o ./templates/password_change.html && \
                  sed -i "s|$EMAIL_TEMPLATES_RECOVERY|./templates/password_change.html|g" supabase/config.toml
                curl -sSL "$EMAIL_TEMPLATES_EMAIL_CHANGE" -o ./templates/email_change.html && \
                  sed -i "s|$EMAIL_TEMPLATES_EMAIL_CHANGE|./templates/email_change.html|g" supabase/config.toml
                
                # Replace SMTP configuration placeholders
                sed -i "s|env(SMTP_HOST)|${SMTP_HOST}|g" supabase/config.toml
                sed -i "s|env(SMTP_PORT)|${SMTP_PORT}|g" supabase/config.toml
                sed -i "s|env(SMTP_USER)|${SMTP_USER}|g" supabase/config.toml
                sed -i "s|env(SMTP_PASS)|${SMTP_PASS}|g" supabase/config.toml
                sed -i "s|env(SMTP_FROM)|${SMTP_FROM}|g" supabase/config.toml
                sed -i "s|env(SMTP_FROM_NAME)|${SMTP_FROM_NAME}|g" supabase/config.toml
                
                echo "Config.toml created with all replacements applied."
              fi
              
              # Link to the existing Supabase project
              echo "Linking to Supabase project: $PROJECT_REF"
              npx supabase link --project-ref "$PROJECT_REF" || {
                echo "ERROR: supabase link failed"
                exit 1
              }
              
              # Push configuration if config.toml exists
              if [ -f "supabase/config.toml" ]; then
                echo "Pushing configuration to Supabase..."
                echo "Y" | npx supabase config push --project-ref "$PROJECT_REF" || {
                  echo "Warning: Config push failed (non-fatal)"
                }
              fi
              
              # Push database schema
              echo "Applying database migrations..."
              echo "Y" | npx supabase db push --include-all
              
              # Enable SSL enforcement (optional, non-fatal)
              echo "Enabling SSL enforcement..."
              npx supabase ssl-enforcement update \
                --enable-db-ssl-enforcement \
                --project-ref "$PROJECT_REF" \
                --experimental || {
                  echo "Warning: SSL enforcement update failed (non-fatal)"
                }
              
              echo "=== Managed Supabase Setup Complete ==="
          env:
            - name: SUPABASE_ACCESS_TOKEN
              valueFrom:
                secretKeyRef:
                  {{- if and .Values.global .Values.global.secrets .Values.global.secrets.secretRef }}
                  name: {{ .Values.global.secrets.secretRef }}
                  key: {{ .Values.global.secrets.secretRefKeys.supabaseAccessToken | default "SUPABASE_ACCESS_TOKEN" }}
                  {{- else }}
                  # Use the rulebricks app secret (created by rulebricks subchart)
                  name: {{ .Release.Name }}-app-secrets
                  key: SUPABASE_ACCESS_TOKEN
                  {{- end }}
            - name: SUPABASE_PROJECT_REF
              value: {{ .Values.global.supabase.projectRef | quote }}
            - name: SUPABASE_URL
              value: {{ .Values.global.supabase.url | quote }}
            - name: SITE_DOMAIN
              value: {{ .Values.global.domain | quote }}
            # Email subject configuration
            - name: EMAIL_SUBJECTS_INVITE
              value: {{ .Values.global.supabase.emails.subjects.invite | quote }}
            - name: EMAIL_SUBJECTS_CONFIRMATION
              value: {{ .Values.global.supabase.emails.subjects.confirmation | quote }}
            - name: EMAIL_SUBJECTS_RECOVERY
              value: {{ .Values.global.supabase.emails.subjects.recovery | quote }}
            - name: EMAIL_SUBJECTS_EMAIL_CHANGE
              value: {{ .Values.global.supabase.emails.subjects.emailChange | quote }}
            # Email template URL configuration
            - name: EMAIL_TEMPLATES_INVITE
              value: {{ .Values.global.supabase.emails.templates.invite | quote }}
            - name: EMAIL_TEMPLATES_CONFIRMATION
              value: {{ .Values.global.supabase.emails.templates.confirmation | quote }}
            - name: EMAIL_TEMPLATES_RECOVERY
              value: {{ .Values.global.supabase.emails.templates.recovery | quote }}
            - name: EMAIL_TEMPLATES_EMAIL_CHANGE
              value: {{ .Values.global.supabase.emails.templates.emailChange | quote }}
            # SMTP configuration (non-sensitive values)
            - name: SMTP_HOST
              value: {{ .Values.global.smtp.host | quote }}
            - name: SMTP_PORT
              value: {{ .Values.global.smtp.port | quote }}
            - name: SMTP_FROM
              value: {{ .Values.global.smtp.from | quote }}
            - name: SMTP_FROM_NAME
              value: {{ .Values.global.smtp.fromName | quote }}
            # SMTP credentials (sensitive - from secret)
            - name: SMTP_USER
              valueFrom:
                secretKeyRef:
                  {{- if and .Values.global .Values.global.secrets .Values.global.secrets.secretRef }}
                  name: {{ .Values.global.secrets.secretRef }}
                  key: {{ .Values.global.secrets.secretRefKeys.smtpUser | default "SMTP_USER" }}
                  {{- else }}
                  name: {{ .Release.Name }}-app-secrets
                  key: SMTP_USER
                  {{- end }}
            - name: SMTP_PASS
              valueFrom:
                secretKeyRef:
                  {{- if and .Values.global .Values.global.secrets .Values.global.secrets.secretRef }}
                  name: {{ .Values.global.secrets.secretRef }}
                  key: {{ .Values.global.secrets.secretRefKeys.smtpPass | default "SMTP_PASS" }}
                  {{- else }}
                  name: {{ .Release.Name }}-app-secrets
                  key: SMTP_PASS
                  {{- end }}
          volumeMounts:
            - name: assets
              mountPath: /assets
      volumes:
        - name: assets
          emptyDir: {}
{{- end }}
